//////////
/// Engine project

- Render thread:
	- Create the render memory and allocate proxies, communicate back with the engine thread.
	- create a command mailbox, which is a function buffer, that async, will be executed on the render thread.

- Create the Texture Manager.
- Create handle for objects to not carry ptrs?

////////////////
//// DAY
///////////////

- Crate the camera free movement, through the mouse.
- Create the infinite scenario.


////////////////////////////////

- Crate a unique vertex buffer and index buffer with all the indeces, bind to the renderer and DrawIndexed.

	Mesh importing
	- Create a hash map for the current indeces, then:
		- hash_map<key, u32> vertex exists - lookup table to quickly see if the vertex exists when importing the mesh.
				: y - then we add a new index to the index array with the already present idx of the vertex.
				: n - then create a new entry in the vertex buffer, add the new vertex idx to the hash map, and to the index buffer.


- Create a list of max meshes that can be represented at once in memory.
- Give the renderer its own arena for the textures and meshes -> separate the engine between arenas so everything is closer in memory.

RENDERER:



WINDOWS:
	- Use direct3D 12 for the graphics:
		- render pixel.
		- render line.
		- render a mesh.


MACOS: 
	- same setup for windows but with METAL as the graphics API.


POST IMPLEMENTATION:
- REFACTOR - Separate the engine and the application.


STRING
- Create a string_t table to check if we have already that string in memory.


PLATFORM:
- Crate a page size function to extract the page size.


C:\Program Files (x86)\Windows Kits\10\Lib\10.0.22621.0\um\x86